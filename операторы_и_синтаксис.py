# Программы состоят из модулей
# Модули содержать операторы,
# Операторы содержат выражения,
# Выражения создают и обрабатывают объекты

# распаковывающее присваивание
"""
name, age = ['lee', 20]"""
# python распаковывает список или кортеж и присваивает им ссылки
# слева на права name='lee' age=20
"""
print(name, age)"""
# расширенная распаковка последовательности
"""
*name, age, other = ('lee', 20, 'city', 'sbp', 10)"""
"""
print(name) """  # ['lee', 20, 'city']
"""
print(age)"""  # sbp
"""
print(other)  # 10
"""
# при помощи оператора * распаковки, переменная будет всегда содержать список
# остатков объектов независимо от положения *
"""
l = [1,2,3,4]
while l:
    front, *l = l
    print(front,l)"""
# 1 [2, 3, 4]
# 2 [3, 4]
# 3 [4]
# 4 []
"""
for (a,*b,c) in [(1,2,3,4), (5,6,7,8), (9,10,11,20,20,20)]:
    print(a,b,c)"""
# 1 [2, 3] 4
# 5 [6, 7] 8
# 9 [10, 11, 20, 20] 20


# функция print
# это форма перенаправления потока данных
# по умолчанию текст отправляется в стандартный поток вывода в той же программе в который выполняется
"""
import sys"""
# stdout - это место куда по умолчанию отправляется текстовый вывод программы
"""
sys.stdout.write('hello world\n')"""
"""
x = 'hello'
y = [1,2,3]
z = 12"""
# записал в файл datafile.txt hello...[1, 2, 3]...12
"""
print(x,y,z, sep='...', file=open('datafile.txt', 'w'))"""
# отображение текста файла
"""
print(open('datafile.txt').read())"""
# hello...[1, 2, 3]...12
# print всего лишь отправляет текст методу sys . stdout. write,
# длинный сценарий
"""
import sys
temp = sys.stdout"""  # сохранение текущего потока с целью его восстановления
"""
sys.stdout = open('datafile.txt', 'a')"""
"""
print('spam')"""  # запись в файл
"""
print(1, 2, 3)"""  # запись в файл
"""
sys.stdout.close() """ # сброс вывода на диск
"""
sys.stdout = temp"""  # восстановление исходного потока
"""
print('back here')"""  # back here
"""
print(open('datafile.txt').read())"""
# spam
# 1 2 3

# короткий сценарий
"""
x = 'hello'
y = [1,2,3]
z = 12
"""
"""
log = open('datafile.txt', 'w')"""
"""
print(x,y,z, sep='\n', file=log)"""  # запись в файл
"""
print(x,y,z)"""  # вывод в исходный stdout

# if - оператор потока управления
"""
def hello():
    return 'hello'
def sum():
    return 1+1

def default():
    return 'Not...function'

branch = {
    'greeting': hello,
    'sum': sum,
    'city': lambda: 'lambda function',
}

print(branch.get('city_', default)())
"""
"""
if ([] == [1,2] and
        {} == {1,2} or
        () == (1,2) or
        {'key': 'value'} == {'name': 'lee'}):
    print('Ok')
    """

"""
if 1: print('hello')"""
"""
a = ['false', 'true'][bool('')]
print(a)
"""
# while

# break - переходит за пределы цикла
# continue - переходит в заголовок цикла
# else - выполняется если цикл завершился без оператора break



"""
lst = [(1,2), (3,4)]"""
# автоматическая распаковка кортежа на каждой итерации
# 1 итерация - x,y = 1,2
# 2 итерация - x,y = 3,4
"""
for x,y in lst:
    print(x, y)"""
"""
lst = [(1,2,3,4), (5,6,7,8)]
for x,*y,z in lst:
    print(x, y, z)"""
# 1 [2, 3] 4
# 5 [6, 7] 8
"""
items = ['aaa', 111, (4,5), 2.01]
test = [(4,5), 3.14]

for key in test:
    for item in items:
        if item == key:
            print(key, 'was found')
            break
    else:
        print(key, 'not found')
"""
# цикл for быстрее чем while

# os.popen os.system
# позволяют задействовать любую программу командной строки на компьютере

# любой объект у которого реализован метод __next__ с генерацией исключения,
# StopIteration, считается итератором
# по такому объекту можно проходить любым итерационным инструментом
# например цикл for
# для файлов iter() не требуется
# файл является итератором сам по себе

# использование итератора файлового объекта
"""
for line in open('datafile.txt'):"""
# вызов метода __next__ и перехват исключения StopIteration
# end='' подавливает \n, так как строки уже его содержат
# без end='' будут чередоваться с пустыми строками
""" print(line.upper(), end='')"""
# итераторы работают внутри python со скоростью скомпилированного кода C,
# а версии с циклом while запускает байт-код python через виртуальную машину python

# списки и другие последовательности не являются итераторами, но содержат итератор в себе
# цикл for выполняет протокол итерации

"""
for i in [1,2,3]"""  # i = iter([1,2,3])
    # next(i)
""" print(i)"""

# списковое включение

# списковое включение работает в 2 раза быстрее
# итерации функционируют со скоростью кода на C внутри интерпретатора
"""
num_lst = [1, 2, 3, 4, 5]
num_lst2 = [n+1 for n in num_lst]
print(num_lst2)"""
# [2, 3, 4, 5, 6]
# то что делает списковое включение
# прописывая такой цикл он проходит через виртуальную машину python
"""
num_lst2 = []
for n in num_lst:
    num_lst2.append(n+1)
print(num_lst2)
"""
# [2, 3, 4, 5, 6]

# чтение с файла без предварительного его открытия
"""
line = [line.rstrip() for line in open('datafile.txt')]"""
# списковые включения автоматически закрывают файлы когда их временные файловые объекты будут подвергаться
# сборке мусора после того как выражение выполниться
"""
print(line)"""
# ['hello', '[1, 2, 3]', '12']
"""
length_file = len(open('datafile.txt').readlines())"""

# инструменты применяющие протокол итерации
#  for
# списковое включение возвращает определенный установленный объект [], {}, {k:v}
# map - прогоняет элементы из итерируемого объекта через функцию и возвращает итерируемый объект
# sorted - возвращает []
# zip - объединяет элементы из итерируемых объектов и возвращает итерируемый объект
# filter - прогоняет элементы из итерируемого объекта через функцию, и возвращает элементы которые являются истинными - возвращает итерируемый объект
# reduce - прогоняет пары элементов в итерируемом объекте через указанную функцию
# enumerate - формирует пары элементов из итерируемого объекта индекс и значение, возвращает итерируемый объект

# все инструменты которые просматривают объект слева на право используют протокол итерации
# функции list, tuple, dict, set
# метод join, in, extend
# присваивание последовательностей


# генераторы
# всегда возвращают итерируемый объект
# range - генерирует числа по запросу - возвращают итерируемый объект, не сохраняет результаты вы память
# сам по себе range не является итератором
# map - возвращают итерируемый объект и сам является итератором, не сохраняет результаты вы память
# zip - возвращают итерируемый объект и сам является итератором, не сохраняет результаты вы память
# filter - возвращают итерируемый объект и сам является итератором, не сохраняет результаты вы память

# range может использовать множество итераторов
"""
r = range(3)
iter_1 = iter(r)
iter_2 = iter(r)
print(next(iter_1)) 
print(next(iter_2))
print(next(iter_1))
print(next(iter_2))"""

# zip map filter только один итератор на одном ходе выполнения
"""
z = zip([1,2,3], [4,5,6])
iter_1 = iter(z)
iter_2 = iter(z)"""
"""
print(next(iter_1))"""  # (1, 4)
# второй итератор iter_2 будет находиться на том же месте, что и первый итератор iter_2
"""
print(next(iter_2)) """  # (2, 5)

# чтобы объект поддерживал множество итераторов
#  метод __iter__ должен возвращать новый объект
#
# чтобы объект поддерживал один итератор
#  метод __iter__ должен возвращать сам себя


# словарные методы keys, values, items
# так же возвращают итерируемые объекты
"""
dict_ = dict(name='lee', age=20)"""
# объект представления ключей словаря
# сам по себе он не является итератором, но имеет итератор,
"""
view = dict_.keys()"""
"""
print(view)"""  # dict_keys(['name', 'age'])
# что бы к нему обратиться - iter(view)
"""
iter_1 = iter(view)
print(next(iter_1))"""  # name

# list comprehensions - это создание нового объекта путем каких то операции с итерируемым объектом
"""
l = [2 ** i for i in range(7)]
x = 5
for index, num in enumerate(l):
    if num == 2 ** x:
        print(f'at index {index}')
        break
else:
    print('not found')
"""




















